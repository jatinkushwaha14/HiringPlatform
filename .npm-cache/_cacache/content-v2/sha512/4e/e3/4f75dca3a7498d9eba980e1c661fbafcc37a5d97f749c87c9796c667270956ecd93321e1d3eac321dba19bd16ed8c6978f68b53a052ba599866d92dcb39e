{"_id":"until-async","name":"until-async","dist-tags":{"latest":"3.0.2"},"versions":{"3.0.2":{"type":"module","name":"until-async","version":"3.0.2","description":"Gracefully handle a Promise using async/await.","main":"./lib/index.js","types":"./lib/index.d.ts","exports":{".":{"types":"./lib/index.d.ts","default":"./lib/index.js"}},"homepage":"https://github.com/kettanaito/until-async","repository":{"type":"git","url":"git+https://github.com/kettanaito/until-async.git"},"author":{"name":"Artem Zakharchenko","url":"https://github.com/kettanaito"},"license":"MIT","funding":"https://github.com/sponsors/kettanaito","keywords":["async","promise","handle","gracefully","tuple","util"],"devDependencies":{"@ossjs/release":"^0.8.1","@rolldown/binding-darwin-arm64":"1.0.0-beta.38","publint":"^0.3.13","tsdown":"^0.15.3","typescript":"^5.9.2","vitest":"^3.2.4"},"scripts":{"dev":"tsdown -w","test":"vitest","lint":"publint","build":"tsdown","release":"release publish"},"_id":"until-async@3.0.2","bugs":{"url":"https://github.com/kettanaito/until-async/issues"},"_integrity":"sha512-IiSk4HlzAMqTUseHHe3VhIGyuFmN90zMTpD3Z3y8jeQbzLIq500MVM7Jq2vUAnTKAFPJrqwkzr6PoTcPhGcOiw==","_resolved":"/tmp/51eeb70507e800e9a1d8232caba23f1e/until-async-3.0.2.tgz","_from":"file:until-async-3.0.2.tgz","_nodeVersion":"22.19.0","_npmVersion":"10.9.3","dist":{"integrity":"sha512-IiSk4HlzAMqTUseHHe3VhIGyuFmN90zMTpD3Z3y8jeQbzLIq500MVM7Jq2vUAnTKAFPJrqwkzr6PoTcPhGcOiw==","shasum":"447f1531fdd7bb2b4c7a98869bdb1a4c2a23865f","tarball":"https://registry.npmjs.org/until-async/-/until-async-3.0.2.tgz","fileCount":9,"unpackedSize":9245,"signatures":[{"keyid":"SHA256:DhQ8wR5APBvFHLF/+Tc+AYvPOdTpcIDqOhxsBHRwC7U","sig":"MEYCIQCOMAPEWwH9csQkAz3OPC/F2PgwMDVH3vFMtLoLjnqFiQIhAKgaZijr+bzy/aizKX2latVcG1EDrUtfLnsp9lvfJx3u"}]},"_npmUser":{"name":"kettanaito","email":"kettanaito@gmail.com"},"directories":{},"maintainers":[{"name":"kettanaito","email":"kettanaito@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages-npm-production","tmp":"tmp/until-async_3.0.2_1758364712609_0.10811232277792038"},"_hasShrinkwrap":false}},"time":{"created":"2025-09-20T10:38:32.549Z","3.0.2":"2025-09-20T10:38:32.813Z","modified":"2025-09-20T10:38:33.446Z"},"maintainers":[{"name":"kettanaito","email":"kettanaito@gmail.com"}],"description":"Gracefully handle a Promise using async/await.","homepage":"https://github.com/kettanaito/until-async","keywords":["async","promise","handle","gracefully","tuple","util"],"repository":{"type":"git","url":"git+https://github.com/kettanaito/until-async.git"},"author":{"name":"Artem Zakharchenko","url":"https://github.com/kettanaito"},"bugs":{"url":"https://github.com/kettanaito/until-async/issues"},"license":"MIT","readme":"# `until-async`\n\nGracefully handle a Promise using `async`/`await`.\n\n## Why?\n\nWith the addition of `async`/`await` keywords in ECMAScript 2017 the handling of Promises became much easier. However, one must keep in mind that the `await` keyword provides no standard error handling API. Consider this usage:\n\n```js\nasync function getUser(id) {\n  const data = await fetchUser(id)\n  // Work with \"data\"...\n}\n```\n\nIn case `fetchUser()` throws an error, the entire `getUser()` function's scope will terminate. Because of this, it's recommended to implement error handling using `try`/`catch` block wrapping `await` expressions:\n\n```js\nasync function getUser(id) {\n  let data = null\n\n  try {\n    data = await asyncAction()\n  } catch (error) {\n    console.error(error)\n  }\n\n  // Work with \"data\"...\n}\n```\n\nWhile this is a semantically valid approach, constructing `try`/`catch` around each awaited operation may be tedious and get overlooked at times. Such error handling also introduces separate closures for execution and error scenarios of an asynchronous operation.\n\nThis library encapsulates the `try`/`catch` error handling in a utility function that does not create a separate closure and exposes a NodeJS-friendly API to work with errors and resolved data.\n\n## Getting started\n\n### Install\n\n```bash\nnpm install until-async\n```\n\n### Usage\n\n```js\nimport { until } from 'until-async'\n\nasync function getUserById(id) {\n  const [error, data] = await until(() => fetchUser(id))\n\n  if (error) {\n    return handleError(error)\n  }\n\n  return data\n}\n```\n\n### Usage with TypeScript\n\n```ts\nimport { until } from 'until-async'\n\ninterface User {\n  firstName: string\n  age: number\n}\n\ninterface UserFetchError {\n  type: 'FORBIDDEN' | 'NOT_FOUND'\n  message?: string\n}\n\nasync function getUserById(id: string) {\n  const [error, data] = await until<UserFetchError, User>(() => fetchUser(id))\n\n  if (error) {\n    return handleError(error.type, error.message)\n  }\n\n  return data.firstName\n}\n```\n\n## Frequently asked questions\n\n### Why does `until` accept a function and not a `Promise` directly?\n\nThis has been intentionally introduced to await a single logical unit as opposed to a single `Promise`.\n\n```js\n// Notice how a single \"until\" invocation can handle\n// a rather complex piece of logic. This way any rejections\n// or exceptions happening within the given function\n// can be handled via the same \"error\".\nconst [error, data] = until(async () => {\n  const user = await fetchUser()\n  const nextUser = normalizeUser(user)\n  const transaction = await saveModel('user', user)\n\n  invariant(transaction.status === 'OK', 'Saving user failed')\n\n  return transaction.result\n})\n\nif (error) {\n  // Handle any exceptions happened within the function.\n}\n```\n\n## Special thanks\n\n- [giuseppegurgone](https://twitter.com/giuseppegurgone) for the discussion about the original `until` API.\n","readmeFilename":"README.md","_rev":"1-5f7091f2039b7c489bc4a5ed6440694a"}